#!/bin/bash
# - pkgbuild_repo
# - upstream_repo
# - upstream_commit
# - PKGBUILD_TAG
# upstream_url

# We'll use the below global env vars, but not treat them as parameter to avoid
# duplicates in result path like /openeuler-20.03-aarch64/openeuler-aarch64-cifs-2003/
# - os
# - os_arch
# - os_version
# - os_mount

## makepkg is a script that automates the building of packages; it can download and validate source files,
## check dependencies, configure build-time settings, compile the sources, install into a temporary root,
## make customizations, generate meta-info, and package everything together.
## See: https://wiki.archlinux.org/index.php/Makepkg

. $LKP_SRC/lib/debug.sh
. $LKP_SRC/lib/env.sh
. $LKP_SRC/distro/common

check_vars()
{
	[ -n "$os" ]			|| die "os is empty"
	[ -n "$os_arch" ]		|| die "os_arch is empty"
	[ -n "$os_version" ]		|| die "os_version is empty"
	[ -n "$pkgbuild_repo" ]		|| die "pkgbuild_repo is empty"
	[ -n "$upstream_commit" ]	|| die "upstream_commit is empty"
	[ -n "$os_mount" ]		|| die "os_mount is empty"
}

mount_pkg_mnt()
{
	[ -n "$LKP_SERVER" ] && {
		mount -t cifs -o guest,vers=1.0,noacl,nouser_xattr,port=446 //$LKP_SERVER$PKG_MNT $PKG_MNT || die "Failed to run mount"
	}
}

mount_dest()
{
	# the same image is mounted to cifs and nfs, the generated cgz files
	# are stored in the nfs directory.
	[[ "$os_mount" = "cifs" ]] && os_mount="nfs"
	pack_to=${os_mount}/${os}/${os_arch}/${os_version}

	PKG_MNT=/initrd/build-pkg
	mkdir -p "$PKG_MNT"

	is_docker || mount_pkg_mnt
}

get_pkgfile()
{
	curl -sS -H 'Content-Type: Application/json' -XPOST "$LKP_SERVER"':8100/git_command' \
		-d '{"git_repo": "'$1'", "git_command": ["git-show", "HEAD:'$2'"]}' -o "${2##*/}"
	}

request_pkg()
{
	local pkgrepo="${pkgbuild_repo%%//*}"
	local pkgpath="./"
	[[ "$pkgrepo" =~ ^archlinux/(packages|community) ]] && pkgpath="${pkgpath}${pkgbuild_repo#*//}/"

	filelist=$(curl -sS -H 'Content-Type: Application/json' -XPOST "$LKP_SERVER"':8100/git_command' \
		-d '{"git_repo": "'${pkgrepo}'", "git_command": ["git-ls-files", "'${pkgpath}'"]}')

	for pkgfile in ${filelist[*]}
	do
		get_pkgfile "${pkgrepo}" "$pkgfile"
	done

	# download PKGBUILD-$tag
	benchmark="${upstream_repo##*/}"
	benchmark="${benchmark%.git}"
	[ -n "$PKGBUILD_TAG" ] && {
		get_pkgfile "pkg/$benchmark" "PKGBUILD-$PKGBUILD_TAG"
		[ -f "PKGBUILD-$PKGBUILD_TAG" ] || die "PKGBUILD-$PKGBUILD_TAG not exist"
		[ -s "PKGBUILD-$PKGBUILD_TAG" ] || die "PKGBUILD-$PKGBUILD_TAG is empty"
	}

	[ -f PKGBUILD ] || die "PKGBUILD not exist"
	[ -s PKGBUILD ] || die "PKGBUILD is empty"
}

create_softlink()
{
	[ -e "$cgz_name" ] || return 0

	local soft_path="$PKG_MNT/${pack_to}/${pkgname}"
	local bm_name=$(basename $(realpath ${cgz_name}))

	if [ -n "$PKGBUILD_TAG" ]; then
		echo "create soft link: ${PKGBUILD_TAG}.cgz -> ${bm_name}"
		ln -sf "${bm_name}" "${soft_path}/${PKGBUILD_TAG}.cgz"
	fi

	echo "create soft link: latest.cgz -> ${bm_name}"
	ln -sf "${bm_name}" "${soft_path}/latest.cgz"
}

replace_source()
{
	echo "source=(" > $1
	for url in ${source[@]}
	do
		echo "$url" | egrep 'git\+|\.git$' && {
			[ -n "$repo_dir" ] && {
				url="\"${repo_dir}git://${LKP_SERVER}/${upstream_repo}#commit=${upstream_commit}\""
			}
		}
		url=$(echo "$url" | sed 's|https://|http://|g')

		echo "$url" >> $1
	done
	echo ")" >> $1
}

build_source_pkg()
{
	repo_dir=""
	source PKGBUILD
	[ -n "$upstream_repo" ] && [ -n "$upstream_url" ] && {

		if [[ "$source" = *::* ]]; then
			repo_dir="${source%%::*}::"
		else
			repo_dir="$(basename ${upstream_url})"
			repo_dir="${repo_dir%.git*}::"
		fi
	}
	replace_source PKGBUILD.src

	[ -n "$PKGBUILD_TAG" ] && replace_source "PKGBUILD-$PKGBUILD_TAG"

	cgz_name="$PKG_MNT/${pack_to}/${pkgname}/${upstream_commit}.cgz"
	PACMAN=true BUILDDIR=$TMP CARCH=$os_arch PKGEXT=.cgz CGZDEST="$cgz_name" \
		$LKP_SRC/sbin/makepkg -A --check --skippgpcheck --config $LKP_SRC/etc/makepkg.conf 2>&1

	[ "$?" == 0 ] || exit 1
	create_softlink

	is_docker || exit 0
	upload_to_target_dir ${PKG_MNT}/${pack_to}/${pkgname}
}

check_vars
mount_dest
request_pkg
build_source_pkg
