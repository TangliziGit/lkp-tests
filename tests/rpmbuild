#!/bin/bash
# - upstream_repo
# - repo_name
# - custom_repo_name
# custom_repo_addr
# repo_addr
# whether_email
# compat_os
# SRPMs jobs not use upstream_repo, Git jobs use all.
# user can add custom_repo_name and custom_repo_addr to setup
# local repo, value can be an array

. $LKP_SRC/lib/debug.sh
. $LKP_SRC/lib/upload.sh
. $LKP_SRC/lib/rpm.sh
. $LKP_SRC/lib/email.sh

: "${compat_os:=budding-openeuler}"

dest_dir="/rpm/upload/${os}-${os_version}/${compat_os}"

die()
{
	rpmbuild_email "rpmbuild_failed"
	echo "$@"
	exit 99
}

from_git()
{
	package_name=${upstream_repo##*/}
	rpm_dest="${dest_dir}/${repo_name}/${os_arch}/Packages"
	src_rpm_dest="${dest_dir}/${repo_name}/source/Packages"

	init_workspace
	download_upstream_repo
}

echo_commit_info()
{
	for i in $(git_pretty_format "$1" "$2" "$3")
	do
		echo "$4+=('"$i"')"
	done
}

get_merge_info()
{
	declare -a name
	declare -a email
	declare -A email_name_hash

	eval $(echo_commit_info "--no-color" "%ae" "$1" email)
	eval $(echo_commit_info "--no-color" "%ce" "$1" email)
	eval $(echo_commit_info "-n1" "%ae" "$2" email)
	eval $(echo_commit_info "-n1" "%ce" "$2" email)

	IFS_SAVE=$IFS
	IFS=$'\n'
	eval $(echo_commit_info "--no-color" "%an" "$1" name)
	eval $(echo_commit_info "--no-color" "%cn" "$1" name)
	eval $(echo_commit_info "-n1" "%an" "$2" name)
	eval $(echo_commit_info "-n1" "%cn" "$2" name)
	IFS=$IFS_SAVE

	for key in "${!email[@]}"
	do
		[[ "${email[$key]}" =~ ^noreply ]] && continue
		email_name_hash["${email[$key]}"]="${name[$key]}"
	done

	IFS_SAVE=$IFS
	IFS=$';'
	eval $3='"${!email_name_hash[*]}"'
	IFS=$IFS_SAVE

	IFS_SAVE=$IFS
	IFS=$','
	eval $4='"${email_name_hash[*]}"'
	IFS=$IFS_SAVE
}

git_pretty_format()
{
	curl -sS -H 'Content-Type: Application/json' -XPOST "$LKP_SERVER"':8100/git_command' -d '{"git_repo": "'${upstream_dir}/${upstream_repo}.git'", "git_command": ["git-log","'$1'","--pretty=format:'$2'", "'$3'"]}'
}

is_git_merge()
{
	curl -sS -H 'Content-Type: Application/json' -XPOST "$LKP_SERVER"':8100/git_command' -d '{"git_repo": "'${upstream_dir}/${upstream_repo}.git'", "git_command": ["git-show", "--no-patch", "--format=%p", "'$1'"]}'
}

rpmbuild_email()
{
	[ -n "$whether_email" ] && {
		if [[ $(is_git_merge "$upstream_commit" | wc -w) -eq 1 ]]; then
			get_merge_info "" "${upstream_commit}" author_email author_name
			send_email $1
		else
			parent_commit=$(is_git_merge $upstream_commit | sed 's/\ /.../')
			get_merge_info "${parent_commit}" "${upstream_commit}" author_email author_name
			send_email $1
		fi
	}
}

from_srpm()
{
	[ -n "$repo_name" ] || die "repo_name is empty"
	[ -n "$repo_addr" ] || die "repo_addr is empty"

	rpm_dest="${dest_dir}/${repo_name}/${os_arch}/Packages"
	src_rpm_dest="${dest_dir}/${repo_name}/source/Packages"

	install_srpm
}

init_workspace()
{
	# generate workspace in ${HOME}
	su lkp -c rpmdev-setuptree
}

download_upstream_repo()
{
	local url="git://${GIT_SERVER}/${upstream_dir}/${upstream_repo}"

	git clone -q "$url" || git clone -q "$upstream_repo" || die "clone git repo ${package_name} failed: $url"
	cd "$package_name" || exit
	[ -n "${upstream_commit}" ] && git checkout -q "${upstream_commit}"
	filelist=($(git ls-files))

	for pkgfile in "${filelist[@]}"
	do
		local dir="SOURCES"

		echo "$pkgfile" | grep -q -E "\\.spec$" && dir="SPECS"
		mv "$pkgfile" "/home/lkp/rpmbuild/${dir}/"
	done
}

add_user_mock()
{
	useradd mock
	useradd mockbuild
}

install_srpm()
{
	add_user_mock

	su lkp -c "rpm -i --nosignature ${repo_addr} >/dev/null" || su lkp -c "rpm -i --nosignature ${repo_addr}/${upstream_repo} >/dev/null" || die "failed to install source rpm: ${repo_addr}/${upstream_repo}"
}

build_rpm()
{
	export spec_dir="/home/lkp/rpmbuild/SPECS"
	[ -n "$package_name" ] &&
		{
			# HTTP is proxy cache friendly
			sed -i 's/^\(Source[^ ]*:[ \t]*\)https/\1http/g' "$(grep http -rl "$spec_dir/"*.spec)"
		}
	startTime=$(date +%Y-%m-%d-%H:%M)
	startTime_s=$(date +%s)
	fix_on_distro
	# Install build dependencies
	yum-builddep -y "$spec_dir"/*.spec 2>&1 || die "failed to solve dependencies"
	# Download tar.gz to default path ${HOME}/rpmbuild/SOURCE
	[ -n "$package_name" ] &&
		{
			su lkp -c "spectool -g -R $spec_dir/"*.spec || die "failed to download source file"
		}
	# Build source and binary packages
	su - lkp -c "rpmbuild -ba ${spec_dir}/*.spec" || die "failed to build rpms"
	endTime=$(date +%Y-%m-%d-%H:%M)
	endTime_s=$(date +%s)

	sumTime=$[ $endTime_s - $startTime_s ]

	echo "RPM build START TIME: $startTime, END TIME: $endTime, Total duration: $sumTime seconds"
}

show_rpm_files()
{
	find /home -type f -name "*.rpm" | grep -v src.rpm
}

show_src_rpm_files()
{
	find /home -type f -name "*.src.rpm"
}

show_spec_file()
{
	find /home -type f -name "*.spec"
}

upload_rpm_pkg()
{
	local rpm_file
	for rpm_file in $(show_rpm_files)
	do
		upload_one_curl ${rpm_file} ${rpm_dest}
	done

	local src_rpm_file
	for src_rpm_file in $(show_src_rpm_files)
	do
		upload_one_curl ${src_rpm_file} ${src_rpm_dest}
	done
}

upload_spec_file()
{
	for spec_file in $(show_spec_file)
	do
		upload_one_curl ${spec_file} ${result_root}
	done
}

handle_rpm_list()
{
	rpm_list=($(show_rpm_files | xargs basename -a))
	srpm_list=($(show_src_rpm_files | xargs basename -a))
	full_list=("${rpm_list[@]}" "${srpm_list[@]}")

	for rpm_index in "${!full_list[@]}"
	do
		rpm_name="${full_list["${rpm_index}"]}"
		full_list["${rpm_index}"]="\"/srv${rpm_dest}/${rpm_name}\""
		[[ ${rpm_name} =~ "src.rpm" ]] && full_list["${rpm_index}"]="\"/srv${src_rpm_dest}/${rpm_name}\""
	done

	full_list=$(echo "${full_list[@]}" | sed 's; ;,;g')
}

update_repo_mq()
{
	handle_rpm_list

	curl -sS -H 'Content-Type: Application/json' -XPOST "${LKP_SERVER}:10003/upload" \
		-d "{\"upload_rpms\": ["${full_list}"]}"
}

add_repo
[ -n "$upstream_repo" ] && from_git || from_srpm
upload_spec_file
build_rpm
upload_rpm_pkg
update_repo_mq
[ -n "$upstream_commit" ] && rpmbuild_email "rpmbuild_success"
exit 0
