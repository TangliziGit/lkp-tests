#!/bin/bash
# SPDX-License-Identifier: MulanPSL-2.0+
# Copyright (c) 2020 Huawei Technologies Co., Ltd. All rights reserved.

set -e

umask 0002

# allow sut os array
# - if job's os not in this array, job won't execute
ALLOW_OS=(
	openeuler
)

WORKSPACE="/usr/local/iso2rootfs"
ENV_DIR="${WORKSPACE}/env"
I2Q_SRC="${WORKSPACE}/iso2qcow2"
CCI_SRC="${WORKSPACE}/compass-ci"

log_info()
{
	echo "[INFO] $*"
}

exit_info()
{
	log_info "$@"
	exit 0
}

die()
{
	echo "[ERROR] $*" >&2
	exit 1
}

############ pre works ############
check_yaml_vars()
{
	log_info "starting check yaml vars ..."

	local yaml_vars=(
		"os"
		"os_arch"
		"os_version"
		"iso2rootfs_cgz"
		"iso_url_file"
		"iso_os"
		"iso_arch"
		"iso_version"
		"rootfs_protocol"
		"rootfs_server"
		"rootfs_path"
		"initrd_http_host"
		"initrd_http_port"
	)

	for yaml_t in "${yaml_vars[@]}"
	do
		[ -n "$(eval echo "\$${yaml_t}")" ] || die "cannot fine value of var: ${yaml_t}."
	done
}

check_iso_name()
{
	# Why need this step:
	#
	# 1. Our current strategy for detecting iso updates is as follows:
	#    - Monitor iso releases for different os (such as Openeuler).
	#    - Openeuler currently provides an http release_iso file that is
	#      updated each time a new iso is released. we can get the
	#      following two contents from this file:
	#      - Latest iso url;
	#      - Latest iso sha256sum; # Can be obtained by splicing:
	#        {latest_iso_url}. sha256sum
	#
	# 2. Regarding the iso name in the iso url, I consulted the support
	#    staff of openeuler's iso release and got the following reply:
	#    - There are currently two kinds of iso names:
	#      - openEuler-2.0-SP8-xxx.iso;
	#      - openEuler-20.03-xxx.iso;
	#    - openEuler-2.0.SP8-xxx. iso is not used for dailybuild;
	#    - Not sure if new uses of iso will be added in the future;
	#
	# 3. So we've prepared an array to fill in iso names to skip and
	#    exclude any additions later.

	local iso_prefixes_to_skip
	case ${iso_os} in
		"openeuler")
			iso_prefixes_to_skip=("openEuler-2.0-SP8")
		;;
		*)
			return
		;;
	esac

	local prefix
	for prefix in "${iso_prefixes_to_skip[@]}"
	do
		[[ ${ISO_NAME} != ${prefix}* ]] ||
			exit_info "${iso_os} haven't release new iso for openEuler, no need to generate rootfs"
	done
}

get_daily_iso_checksum()
{
	ISO_URL="$(curl "${iso_url_file}")"
	[ "${iso_os}" == "openeuler" ] && {
		local pub_ip=$(echo "${iso_url_file}" | grep -oEw "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}")
		ISO_URL="$(curl "${iso_url_file}" |sed -r "s/[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/${pub_ip}/g")"
	}

	ISO_NAME=$(basename "$ISO_URL")
	ISO_CHECKSUM_URL="${ISO_URL}.sha256sum"
	check_iso_name

	curl -o "${CHECKSUM_FILE_CACHE}.tmp" "${ISO_CHECKSUM_URL}"
	SHA256SUM_NET=$(awk '{print $1}' "${CHECKSUM_FILE_CACHE}.tmp")
}

mount_rootfs()
{
	case ${rootfs_protocol} in
		"nfs")
			ROOTFS_SERVER_PATH="${rootfs_server}:${rootfs_path}/${iso_os}/${iso_arch}"
			install_pkgs "nfs-utils"
		;;
		"cifs")
			ROOTFS_SERVER_PATH="//${rootfs_server}/${rootfs_path}/${iso_os}/${iso_arch}"
			ROOTFS_MOUNT_PARAM="guest,vers=1.0,noacl,nouser_xattr"
			install_pkgs "cifs-utils"
		;;
		*)
			die "cannot support the rootfs_protocol: ${rootfs_protocol}."
		;;
	esac

	ROOTFS_LOCAL_PATH="${WORKSPACE}/compass_os_${iso_os}_${iso_arch}"

	[ -d "${ROOTFS_LOCAL_PATH}" ] || mkdir -p "$ROOTFS_LOCAL_PATH"
	if [ -n "${ROOTFS_MOUNT_PARAM}" ]
	then
		mount -t ${rootfs_protocol} -o "${ROOTFS_MOUNT_PARAM}" "${ROOTFS_SERVER_PATH}" "${ROOTFS_LOCAL_PATH}"
	else
		mount -t ${rootfs_protocol} "${ROOTFS_SERVER_PATH}" "${ROOTFS_LOCAL_PATH}"
	fi
}

get_cache_iso_checksum()
{
	mount_rootfs

	CHECKSUM_FILE_CACHE="${ROOTFS_LOCAL_PATH}/${iso_version}-latest.sha256sum"
	[ ! -f "${CHECKSUM_FILE_CACHE}" ] ||
		SHA256SUM_CACHE=$(awk '{print $1}' "$CHECKSUM_FILE_CACHE")
}

check_sha256sum_update()
{
	get_cache_iso_checksum
	get_daily_iso_checksum

	if [ -n "$SHA256SUM_CACHE" ]
	then
		[ -n "$SHA256SUM_NET" ] || die "cannot get sha256sum of dailybuild iso."

		if [ "$SHA256SUM_CACHE" == "$SHA256SUM_NET" ]
		then
			rm -f "${CHECKSUM_FILE_CACHE}.tmp"
			exit_info "${iso_os} haven't release new iso, no need to generate rootfs"
		else
			log_info "${iso_os} release a new iso, start to generate rootfs ..."
			return
		fi

	else
		log_info "${CHECKSUM_FILE_CACHE} doesn't exist, start to generate rootfs ..."
		return
	fi
}

check_os()
{
	log_info "starting check os ..."
	echo "${ALLOW_OS[@]}" | grep -wq "${os}" ||
		die "current os is not in allow os.
			current os: ${os}.
			allow os: \(${ALLOW_OS[@]}\)"
}

get_cgz()
{
	local cgz_url="http://${initrd_http_host}:${initrd_http_port}/initrd/pkg/nfs/${os}/${os_arch}/${os_version}/${iso2rootfs_cgz}"
	local cgz_name
	cgz_name=$(basename "${cgz_url}")
	local cgz_path_t=${ENV_DIR}/${cgz_name}
	CGZ_PATH=${ENV_DIR}/${cgz_name%.cgz}

	[ -d "$ENV_DIR" ] || mkdir -p "$ENV_DIR"
	[ -f "${cgz_path_t}" ] && rm -f "${cgz_path_t}"
	wget -c -O "${cgz_path_t}" "${cgz_url}"

	[ -d "$CGZ_PATH" ] && rm -rf "$CGZ_PATH"
	mkdir -p "$CGZ_PATH"
	tar -xf "${cgz_path_t}" -C "${CGZ_PATH}"
}

install_pkgs()
{
	local pkg_installer
	command -v yum && pkg_installer="yum"

	[[ -n "$pkg_installer" ]] || die "cannot find pkg installer."

	local pt
	for pt
	do
		"$pkg_installer" install -y "$pt" || die "cannot install pkg: $pt."
	done
}

config_git_proxy()
{
	if [[ -n ${GITCACHE_HOST} ]] && [[ -n ${GITCACHE_PORT} ]]
	then
		git config --system url."http://${GITCACHE_HOST}:${GITCACHE_PORT}/".insteadOf "https://"
	fi
}

config_iso2rootfs()
{
	log_info "starting config iso2rootfs env ..."
	install_pkgs "wget"
	get_cgz

	source "${CGZ_PATH}/config"

	install_pkgs "git"
	config_git_proxy
}

pre_works()
{
	check_yaml_vars
	check_sha256sum_update
	check_os

	config_iso2rootfs
}

############ iso2qcow2 ############
download_iso2qcow2()
{
	[ -d "${I2Q_SRC}" ] && rm -rf "${I2Q_SRC}"
	git clone "$ISO2QCOW2_GIT_URL" "${I2Q_SRC}"
}

config_pip_proxy()
{
	if [[ -n ${SQUID_HOST} ]] && [[ -n ${SQUID_PORT} ]]
	then
		sed -i "s|^PIP_PROXY=|PIP_PROXY=\"http://$SQUID_HOST:$SQUID_PORT\"|g" "${I2Q_SRC}/conf/config"
	fi
}

config_iso_conf()
{
	local config_file="${I2Q_SRC}/conf/iso/iso.conf"
	sed -i "s|^OS=.*|OS=\"${iso_os}\"|g" "$config_file"
	sed -i "s|^OS_ARCH=.*|OS_ARCH=\"${iso_arch}\"|g" "$config_file"
	sed -i "s|^OS_VERSION=.*|OS_VERSION=\"${iso_version}\"|g" "$config_file"
}

config_iso_url()
{
	local iso_url_file="${I2Q_SRC}/conf/iso/net-iso/${iso_os}/${iso_arch}/${iso_version}"
	sed -i "s|^iso_url=.*|iso_url=\"${ISO_URL}\"|g" "${iso_url_file}"
	sed -i "s|^iso_checksum_url=.*|iso_checksum_url=\"${ISO_CHECKSUM_URL}\"|g" "${iso_url_file}"
}

config_iso2qcow2()
{
	log_info "starting config iso2qcow2 env ..."
	download_iso2qcow2

	config_pip_proxy
	config_iso_conf
	config_iso_url
}

run_iso2qcow2()
{
	log_info "starting run iso2qcow2 ..."
	${I2Q_SRC}/auto-install-iso.sh
}

############ qcow2rootfs ############
download_compass_ci()
{
	[ -d "${CCI_SRC}" ] && rm -rf "${CCI_SRC}"
	git clone "$COMPASS_CI_GIT_URL" "${CCI_SRC}"
}

config_rootfs_dir()
{
	ROOTFS_DES_DIR=${ROOTFS_LOCAL_PATH}/${iso_version}-$(date "+%Y-%m-%d-%H-%M-%S")
	[ -d "${ROOTFS_DES_DIR}" ] &&
		ROOTFS_DES_DIR="${ROOTFS_DES_DIR}-${HOSTNAME##*--}"
	mkdir -p "$ROOTFS_DES_DIR"
}

config_qcow2rootfs()
{
	log_info "starting config qcow2rootfs env ..."
	download_compass_ci

	install_pkgs "docker"
	systemctl start docker

	config_rootfs_dir
	export CCI_SRC
	export HOME="/root"

	cd "${CCI_SRC}/container/qcow2rootfs"
	./build

	cd "${CCI_SRC}/container/dracut-initrd"
	./build
}

run_qcow2rootfs()
{
	log_info "starting run qcow2rootfs ..."
	local qcow2_path="${I2Q_SRC}/output/${ISO_NAME%.iso}.qcow2"

	cd "${CCI_SRC}/container/qcow2rootfs"
	./run "${qcow2_path}" "${ROOTFS_DES_DIR}"
}


############ config rootfs ############
config_dns_resolver()
{
	cat <<-EOF > "${ROOTFS_DES_DIR}/etc/resolv.conf"
	nameserver 114.114.114.114
	nameserver 8.8.8.8
	EOF
}

disable_selinux()
{
	sed -i 's/^SELINUX=.*/SELINUX=disabled/g' "${ROOTFS_DES_DIR}/etc/selinux/config"
}

config_rootfs()
{
	config_dns_resolver
	disable_selinux
}

############ test rootfs ############
get_qemu_efi_fd()
{
	source "$I2Q_SRC"/lib/tools/checker.sh
	source "$I2Q_SRC"/lib/os/hoster.sh
	source "$I2Q_SRC"/lib/libvirt/libvirt_vars.sh

	get_host_info
	get_efi_fd_path
}

test_rootfs()
{
	log_info "starting test rootfs ..."
	local test_script="${CGZ_PATH}/kvm.sh"

	local kernel_path=$(realpath "${ROOTFS_DES_DIR}"/boot/vmlinuz*|grep -v rescue)
	local initrd_lkp_path=$(realpath "${ROOTFS_DES_DIR}"/boot/initramfs.lkp*)
	local root_path
	case ${rootfs_protocol} in
		"nfs")
			root_path="${ROOTFS_SERVER_PATH}/$(basename "${ROOTFS_DES_DIR}")"
		;;
		"cifs")
			root_path="cifs:${ROOTFS_SERVER_PATH}/$(basename "${ROOTFS_DES_DIR}"),${ROOTFS_MOUNT_PARAM}"
		;;
		*)
			die "cannot support the rootfs_protocol: ${rootfs_protocol}."
		;;
	esac
	get_qemu_efi_fd

	sed -i "s|KERNEL|\"${kernel_path}\"|g" "$test_script"
	sed -i "s|INITRD_LKP|\"${initrd_lkp_path}\"|g" "$test_script"
	sed -i "s|ROOT|\"${root_path}\"|g" "$test_script"
	sed -i "s|QEMU_EFI_FD|\"${EFI_FD_PATH}\"|g" "$test_script"

	cd "$(dirname "${test_script}")"

	expect << EOF
		# timeout for kvm.sh
		set timeout 300

		spawn "/bin/bash"
		match_max 100000

		expect -exact "# " {
		send -- "./$(basename "${test_script}")\r"
		}

		expect {
			"localhost login: " {
				send_user "\[INFO\] test rootfs ok"
				exit 0
			}
			"server * not responding, timed out" {
				send_user "\[WARNING\] rootfs can start, but need to disable some services"
				exit 0
			}
			timeout {
				send_user "\[ERROR\] test rootfs time out"
				exit 1
			}
		}
EOF
}

############ submit test job yaml ############
generate_global_yaml()
{
	local config_yaml="/etc/compass-ci/defaults/sparrow.yaml"

	mkdir -p "$(dirname "${config_yaml}")"
	echo "SCHED_HOST: ${SCHED_HOST}" >> "${config_yaml}"
	echo "SCHED_PORT: ${SCHED_PORT}" >> "${config_yaml}"
}

generate_submit_append_str()
{
	local wait_add_vars=(
		"os"
		"os_arch"
		"os_version"
		"os_mount"
		"testbox"
	)
	for vt in "${wait_add_vars[@]}"
	do
		SUBMIT_APPEND_STR="${SUBMIT_APPEND_STR} ${vt}=$(eval echo "\$test_${vt}")"
	done
}

submit_test_job_yaml()
{
	[ -n ${test_yaml} ] || return 0

	log_info "starting submit ${test_yaml} ..."

	[ -d "${LKP_SRC}" ] || die "cannot find value of var: LKP_SRC."

	local test_yaml_vars=(
		"test_os"
		"test_os_arch"
		"test_os_version"
		"test_os_mount"
		"test_testbox"
	)

	for yaml_t in "${test_yaml_vars[@]}"
	do
		[ -n "$(eval echo "\$${yaml_t}")" ] || die "cannot fine value of var: ${yaml_t}."
	done

	cd "${LKP_SRC}" && {
		chmod +x ./sbin/install-dependencies.sh
		./sbin/install-dependencies.sh

		generate_global_yaml
	}

	cd "${LKP_SRC}/jobs" && {
		[ -f "${test_yaml}" ] ||
			die "cannot find test yaml in LKP_SRC/jobs.
				test yaml: ${test_yaml}."

		generate_submit_append_str

		"${LKP_SRC}/sbin/submit" ${SUBMIT_APPEND_STR} "${test_yaml}"
	}

	log_info "submit ${test_yaml} finished"
}

############ post works ############
post_works()
{
	log_info "starting post works ..."

	mv "${CHECKSUM_FILE_CACHE}.tmp" "${CHECKSUM_FILE_CACHE}"

	local soft_link="${iso_version}-dailybuild"
	cd "${ROOTFS_LOCAL_PATH}" &&
		rm -f "${soft_link}" &&
			ln -s "$(basename "${ROOTFS_DES_DIR}")" "${soft_link}"

	cd / && umount "${ROOTFS_LOCAL_PATH}"

	log_info "iso2rootfs finished"
}

############ main ############
main()
{
	pre_works

	config_iso2qcow2
	run_iso2qcow2

	config_qcow2rootfs
	run_qcow2rootfs

	config_rootfs

	test_rootfs
	submit_test_job_yaml

	post_works
}

main
